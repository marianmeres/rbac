# @marianmeres/rbac - LLM Knowledge Base

## Package Overview

Name: @marianmeres/rbac
Version: 2.0.1
Type: TypeScript library
Purpose: Role-Based Access Control (RBAC) with optional Attribute-Based Access Control (ABAC)
Author: Marian Meres
License: MIT
Repository: https://github.com/marianmeres/rbac

## Runtime Support

- Deno (primary)
- Node.js (via NPM distribution)
- Browsers (no server-specific APIs)
- Zero production dependencies

## Installation

Deno: deno add jsr:@marianmeres/rbac
Node.js: npm install @marianmeres/rbac

## Core Concepts

### Permission
A string identifier for an action. No implicit wildcard expansion - exact string matching only.
Examples: "article:read", "user:delete", "*:*", "endpoint:/users"

### Role
A named set of permissions assigned to users. Can have direct permissions and inherit from groups.
Examples: "admin", "editor", "viewer"

### Group
A reusable set of permissions shared by multiple roles. Provides inheritance hierarchy.
Examples: "admins", "editors", "content-managers"

## File Structure

```
src/
  mod.ts          - Main entry point (re-exports rbac.ts)
  rbac.ts         - Core implementation (~596 lines)
tests/
  rbac.test.ts    - Comprehensive test suite (~633 lines)
scripts/
  build-npm.ts    - NPM package builder
deno.json         - Configuration and metadata
```

## Exported Types

```typescript
interface RbacRoleInternal {
  permissions: Set<string>;
  memberOf: Set<string>;
}

interface RbacGroupInternal {
  permissions: Set<string>;
}

type RbacRuleFunction = (
  subject: Record<string, any>,
  resource?: Record<string, any>,
  context?: Record<string, any>
) => boolean;

interface RbacDump {
  roles: Record<string, Partial<Record<"permissions" | "memberOf", string[]>>>;
  groups: Record<string, Partial<Record<"permissions", string[]>>>;
}
```

## Main Export: class Rbac

### Constructor
```typescript
new Rbac()  // Creates empty RBAC instance
```

### Group Management Methods

| Method | Signature | Description |
|--------|-----------|-------------|
| addGroup | (name: string, permissions?: string[]) => Rbac | Create/update group. Chainable. |
| removeGroup | (name: string) => Rbac | Remove group and clean up role references. Chainable. |
| removeGroupPermissions | (name: string, permissions: string[]) => Rbac | Remove specific permissions from group. Chainable. |
| hasGroup | (name: string) => boolean | Check if group exists. |
| getGroups | () => string[] | Get all group names. |

### Role Management Methods

| Method | Signature | Description |
|--------|-----------|-------------|
| addRole | (name: string, permissions?: string[], groupNames?: string[]) => Rbac | Create/update role. Throws if group doesn't exist. Chainable. |
| removeRole | (name: string) => Rbac | Remove role entirely. Chainable. |
| removeRolePermissions | (name: string, permissions: string[]) => Rbac | Remove specific permissions from role. Chainable. |
| hasRole | (name: string) => boolean | Check if role exists. |
| getRoles | () => string[] | Get all role names. |
| addRoleToGroup | (roleName: string, groupName: string) => Rbac | Add role to group. Creates role if missing. Throws if group doesn't exist. Chainable. |
| removeRoleFromGroup | (roleName: string, groupName: string) => Rbac | Remove role from group. Chainable. |

### Permission Check Methods (RBAC)

| Method | Signature | Description |
|--------|-----------|-------------|
| hasPermission | (roleName: string, permission: string) => boolean | Check if role has specific permission (direct or inherited). |
| hasSomePermission | (roleName: string, permissions: string[]) => boolean | Check if role has ANY of the given permissions (OR logic). |
| getPermissions | (roleName: string) => Set<string> | Get all permissions for role (merged from groups + direct). |

### ABAC Methods

| Method | Signature | Description |
|--------|-----------|-------------|
| addRule | (permission: string, rule: RbacRuleFunction) => Rbac | Add conditional rule for permission. Chainable. |
| removeRule | (permission: string) => Rbac | Remove rule from permission. Chainable. |
| hasRule | (permission: string) => boolean | Check if rule exists. |
| getRules | () => string[] | Get all permissions with rules. |
| can | (subject: {role: string, ...}, permission: string, resource?: Record, context?: Record) => boolean | Check permission with RBAC + optional rule evaluation. |

### Serialization Methods

| Method | Signature | Description |
|--------|-----------|-------------|
| toJSON | () => RbacDump | Get configuration as plain object. |
| dump | () => string | Serialize to JSON string. |
| Rbac.restore | (dump: string \| RbacDump) => Rbac | Static method. Create new instance from dump. Groups restored before roles. |

## ABAC Rule Evaluation Flow

1. RBAC check via hasPermission(subject.role, permission)
2. If RBAC fails → return false
3. If RBAC passes and no rule exists → return true
4. If rule exists → evaluate rule(subject, resource, context) → return result

## Common Usage Patterns

### Basic RBAC Setup
```typescript
import { Rbac } from "@marianmeres/rbac";

const rbac = new Rbac();

rbac
  .addGroup("admins", ["*:*"])
  .addGroup("editors", ["article:read", "article:update"])
  .addRole("admin", [], ["admins"])
  .addRole("editor", [], ["editors"])
  .addRole("user", ["article:read"], []);

rbac.hasPermission("admin", "*:*");              // true
rbac.hasPermission("editor", "article:update");  // true
rbac.hasPermission("user", "article:update");    // false
```

### ABAC Ownership Check
```typescript
rbac
  .addRole("author", ["article:update", "article:delete"])
  .addRule("article:update", (subject, resource) => {
    if (subject.role === "author") {
      return resource?.authorId === subject.id && resource?.status === "draft";
    }
    return true;
  });

rbac.can(
  { role: "author", id: "user123" },
  "article:update",
  { authorId: "user123", status: "draft" }
); // true
```

### Serialization and Persistence
```typescript
const dump = rbac.dump();
localStorage.setItem("rbac-config", dump);

const rbac2 = Rbac.restore(localStorage.getItem("rbac-config"));
```

## Important Behaviors

1. Permission matching is EXACT string comparison only - no wildcard expansion
2. Groups MUST exist before adding roles to them (throws Error)
3. Removing a group automatically removes it from all roles
4. Roles can belong to multiple groups
5. Duplicate permissions are automatically deduplicated (uses Set)
6. ABAC rules are NOT serialized - must re-add after restore()
7. All mutating methods return `this` for chaining
8. Empty role/group names are valid (edge case)
9. Special characters in names are supported (unicode, dashes, dots, emails)

## Error Conditions

- addRole with non-existent group → throws Error("Group 'X' does not exist")
- addRoleToGroup with non-existent group → throws Error("Group 'X' does not exist")
- Rbac.restore with invalid JSON → throws Error("Unable to restore dump: ...")

## Test Coverage

35 comprehensive tests covering:
- Basic RBAC functionality (roles, groups, permissions)
- Role-group relationships
- Permission inheritance
- Serialization/deserialization
- ABAC rules and evaluation
- Edge cases (empty names, special characters, long lists, duplicates)

## Design Patterns

- Fluent API (method chaining)
- Lazy initialization (roles/groups auto-created on first reference)
- Set-based deduplication
- Private fields (#roles, #groups, #rules)
- Static factory method (Rbac.restore)

## Version History

- v2.0.1 - Current (gitignore addon)
- v2.0.0 - ABAC support added
- v1.x - Initial RBAC-only versions
